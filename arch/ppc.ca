Reg cc  { code = 0 } , eax { code = 0 } ;
Reg ecx { code = 1 } , ebx { code = 2 } , edx { code = 3 } ;
Reg esp { code = 4 } ;
Reg ebp { code = 5 } ;
Reg esi { code = 6 } ;
Reg edi { code = 7 } ;

RegClass flags    { bits = 16, regs = [cc] } ;
RegClass gpr      { bits = 32, regs = [eax, ecx, ebx, edx, esp, ebp, esi, edi] } ;
RegClass gpr_byte { bits = 32, regs = [eax, ecx, ebx, edx] } ;
RegClass gpr_eax  { bits = 32, regs = [eax] } ;
RegClass gpr_edx  { bits = 32, regs = [edx] } ;
RegClass gpr_esp  { bits = 32, regs = [esp] } ; 

#Reg eax{code=2},ebx{code=3},eck{code=45} ;
#Reg bla{code=100},ikl{code=101} ;
#Reg r{code=45} ;

#Reg bldium{code=56} ;

#RegClass
#	intregs{
#		bits=32,
#    bits=24,
#		regs=[eax,fpregs,c,d,e,f]
#};
#RegClass fpregs{
#		bits=64,
#		regs=[r,f4,f6,fpregs,zu]
#},
#	statusregs{
#		bits=32,
#		regs=[r,f4,f6]
#} ;
#RegClass blub{
#	bits = 24,	
#	regs=[r,bla,ikl]
#} ;
#RegClass gpc{
#  bits = 32,
#  regs=[r,bla]
#} ;

#RegClass
#hallo{
#	bits=32,
#	regs=[i,e,r]
#} ;
%%

Instr store{
input = [Int blub, Int blub, gpr b, gpr_esp c, foobar f],
output = []
} ;
#load{
#output = [],
#immediate = [tum hallo]
#},
#add{
#input = [hass jo],
#output = [int bla],
#immediate = [blub tra]	
#} ;

#Instr sub{
#input = [int bla],
#output = [blub ha],
#immediate = [Int k],
#encoding = ha.code[1:3]
#} ;

#%%

#Int fct(Int b) = b.code

#Int foobar() = 45
